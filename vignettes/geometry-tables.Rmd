---
title: "Geometry in tables"
author: "Michael D. Sumner"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Geometry in Tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `sp` and `ggplot2` packages are both widely used in R for plotting maps. The visualization tools in `ggplot2` are very general and can be used for plotting a very wide variety of data visualizations as well as maps, but the data structures used are not aligned with how map data are usually stored. The tools and data structure tools for `sp` are very powerful and can be used for a wide variety of map-data manipulations and visualizations, but they are not inherently extensible. 

This document aims to show that there are opportunities to bridge these seemingly disparate domains, and bring the general, data frame table-based idioms of `ggplot2` into the specialized domain of spatial data. 

## Two worlds and two tables 

A `Spatial` object is a complex S4 classed structure composed of lists of coordinates, values, and metadata. It has

* a data frame of attributes for each individual map object
* a complex hierarchical list of matrices of coordinates (x and y, or longitude and latitude)
* projection metadata
* a bounding box

The geometry is in the complex list, and this is defined *just-so* by S4 classes with rigourous constraints to conform to spatial standards. This includes determined details such as the "winding" order for rings defining polygon islands or holes, and the details of which hole belongs to which island. 

A `ggplot2` 'object' is a data frame, and---ok---it's not really an object. It has columns: 

* "long" and "lat" to store the 'x' and 'y' coordinates (or longitude and latitude)
* "id" to identify each map object
* "group" to identify each "piece" (polygon ring, line-path, or [multi-]point), unique across all objects
* "piece" to identify each "piece" within "id" (unique only within ID, provides a count of pieces)
* "order" to record the correct winding order, or path order 
* "hole" to denote if a polygon ring was a hole or an island

There's one major thing missing still, the `ggplot2` case is really two data frames, and the list neglects the exact same data frame that we listed first for 'sp'. This table is rarely mentioned explicitly, since in all ggplot2 examples it only gets used in a merge step, to copy its attribute metadata on id to all the coordinates. 


The other parts missing from ggplot2 is the details about which hole belongs to which island, the projection metadata, and the bounding box. T
(I'm only talking about sp Spatial classes here, but the same scheme is used by gg tools for the maps package, and c. ...).

What else is missing? 

- identifiers on parts, ggplot understands this and maps provides it (with limitations)
- identifiers on coordinates 
- topology

## Specific example

To illustrate the relation between `sp` and `ggplot2`, read in a polygon layer from the `maps` package and convert, and plot. 

```{r,eval=TRUE}
library(maps)
## there's a long side-story here, that we ignore for now
amap <- map("world", plot = FALSE, resolution = 0, fill = TRUE)
map(amap, fill = TRUE)
str(amap)
```

This is a simple list structure, with 'x' and 'y' values separate by 'NA', and a 'names' vector. 

There is a name element for every "NA-separated" section. 

```{r}
sum(is.na(amap$x))
```

To plot this with gpplot2 we need a single table. 

```{r}
fortify.map <- function(x) {
  bad <- is.na(x$x)
  seq_ids <- cumsum(bad) + 1L
  data.frame(x = x$x, y = x$y, group = seq_ids, id = seq_ids)[!bad, ]
}
library(ggplot2)
amaptab <- fortify(amap) 

ggplot(amaptab) + aes(x = x, y = y, group = group, fill = group) + geom_polygon()
```

### Problem 1

If you look carefully there are two big problems, there's an awkward polygon catastrophe a the "southern boundary" of Antarctica - it becomes much clearer if we zoom in. 

```{r}
## for now, it's easier to subset by re-reading
ant <- map("world", regions = "Antarctica", plot = FALSE, fill = TRUE)
ggplot(fortify(ant)) + aes(x = x, y = y, group = group, fill = group) + geom_polygon() + geom_path()
```

The problem is that in this coordinate system, there's no extension of the continent to the "south pole", and so the polygon wraps around awkwardly, leaving a dangle in the west. The issue is more apparent by including the boundary, with 'geom_path'. 

There's no "fixing" this without putting on the dummy coordinates at [-180, -90] and [180, -90] - but we are stuck since when we do that we then get the funny boundary dangle when plotted in a reasonable projection. 

Here's a plot *without* the extra coordinates at the poles. 

```{r}
library(ggalt)
prj <- "+proj=laea +lat_0=-90 +ellps=WGS84 +lon_0=140"
ggplot(fortify(ant)) + aes(x = x, y = y, group = group, fill = group) + geom_polygon() + geom_path() + coord_proj(prj)
```

Here's one where the extra coordinates are present. 

```{r}
library(maptools)
data(wrld_simpl)
ant2 <- subset(wrld_simpl, NAME == "Antarctica")
rownames(ant2) <- NULL
## note it's now called "long"/"lat" not "x"/"y"
ggplot(fortify(ant2)) + aes(x = long, y = lat, group = group, fill = group) + geom_polygon() + geom_path() + coord_proj(prj) + guides(fill = FALSE)
```


### Problem 2 

The second problem is that we are not drawing holes correctly. To see this zoom in on southern Africa, where the country of Lesotho punches out a hole in South Africa. 

```{r}
## for now, it's easier to subset by re-reading
afr <- map("world", regions = c("South Africa", "Lesotho"), plot = FALSE, fill = TRUE)
ggplot(fortify(afr)) + aes(x = x, y = y, group = group, fill = group) + geom_polygon() + geom_path()
```

That looks ok, but see what happens when we take just South Africa. 

```{r}
## for now, it's easier to subset by re-reading
library(ggpolypath)
safr <- map("world", regions = "South Africa", plot = FALSE, fill = TRUE)
ggplot(fortify(safr)) + aes(x = x, y = y, group =group, col = factor(group)) + geom_polypath() + geom_path() 
```

The data for South Africa is literally stored with the hole it needs to be plotted on its own, as well as the same "island" needed for Lesotho. 

We can get the hole with polypath, but this reminds us that we are double-storing a lot of coordinates - this is the same for any neighbouring polygons, all those shared boundaries and not "shared", they are stored explicitly. 




Finally, show that sp plots the hole just fine without any effort. 

```{r}
library(dplyr)
sp_afr <- fortify(afr) %>% 
  transmute(x_ = x, y_ = y, object_ = unlist(lapply(strsplit(afr$names[id], ":"), "[", 1L)), branch_ = id, 
         island_ = !grepl("hole", afr$names[id]), order_ = row_number()) %>% 
  spbabel::sp()

plot(sp_afr, col = rainbow(nrow(sp_afr)))
plot(sp_afr[2, ], col = "grey")
```


## spbabel

There are two functions in `spbabel` that try to re-unite these two tables. 

sptable - fortify but with new names

sp - a driver function to produce Spatial objects, in this case 'spFromDataFrame'

This is not done with a single object with a special class, but it could be. 

```{r, eval=FALSE}
#PSEUDOCODE

obj <- list(maptab, dattab); class(obj) <- "twotable_geom"

plot.twotable-geom <- function(x, ...) x

`[.twotable_geom <- function(x, i, j, ...) x
  
plot(obj[1, ])

```

Another way to do this is to nest the tables, something we'll explore in another document. 

Perhaps the best thing about having everything stored in two tables is that we can push it out to a database, pass that to someone else and everything is transferred correctly. 

```{r,eval=FALSE}
#RSQLITE with dplyr

```
Another document that receives this database and explores nesting, demand-read. 


## Tidy tables

We have tidied up in one sense, we've removed a complicated object with specialist requirements and created two tables that can be plotted and manipulated with generic tools. 

There is redundancy in the geometry table. 'Tidy' means '3NF' or 'third-normal-form', and 3NF means that we remove the repeated values that could be stored just once. 

How do we remove this redundancy? First identify the entities that exist. 

Objects, parts, coordinates. 


If we create a "parts" table, we will have three tables, one with all the x/y coordinates and their part ID and order within part, the parts table with attributes part ID, island status, and the object metadata table. 

Benefit is size of data is reduced. 

## Four tables

Further normalizatoin inserts a partXcoord table, and puts the order and vertex id on this. 
Benefit is 

- further data reduction 
- removal of duplicated coordinates
- ability to demand page
- ready for topology

